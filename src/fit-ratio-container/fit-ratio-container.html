<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="zoom-container">
  <template>
    <style>
      :host {
        /* Pretty much how you'd normally fit a <div> */
        @apply(--layout-fit);

        /* Pretty much how you'd normally center a <div> */
        @apply(--layout);
        @apply(--layout-center);
        @apply(--layout-center-justified);
      }

      :host[pannable] {
        cursor: grab;
      }

      :host[panning] {
        cursor: grabbing;
      }
    </style>
    <content></content>
  </template>
  <script>
    // @ts-check

    const component = {
      is: 'zoom-container',

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_onIronResize'
      },

      properties: {
        dimensions: {
          type: String,
          value: "1/1",
          observer: '_onDimensionsChanged'
        },

        /**
         * Faux-margins around the content element for zoom-to-fit.
         * Prefer this over regular margins, since pointer events in that area
         * like clicking or scrolling wouldn't be picked up by listeners.
         */
        margins: {
          type: Number,
          value: 16,
        },

        pannable: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
        },

        panning: {
          type: Boolean,
          value: false,
          readOnly: true,
          reflectToAttribute: true,
        },

        fit: {
          type: Boolean,
          value: true,
          reflectToAttribute: true,
          observer: "_onFit",
        },

        zoom: {
          type: Number,
          value: 1,  // Relative to the canvas elemt, not the viewport!
          observer: "_onZoom",
        },

        /**
         * Tells how offset our midpoint is from the viewport midpoint, from
         * the transform's perspective.
         */
        position: {
          type: Array,
          value: [0, 0],
        },

        MINIMUM_ZOOM: {
          type: Number,
          value: 0.2,
          readOnly: true,
        },

        MAXIMUM_ZOOM: {
          type: Number,
          value: 10,
          readOnly: true,
        },
      },

      _contentDimensions: {
        width: 1,
        height: 1,
      },

      _ratio: 1,

      _notifyFit: true,

      /** @type {number[]} The initial `this.position` of a move. */
      _initialPosition: null,

      /** @type {number[]} The initial cursor position of a move. */
      _initialPointerPosition: null,

      get contentElement() {
        return this.getContentChildren()[0];
      },

      // Event listeners

      ready: function() {
        // Safari/WebKit doesn't support screen.orientation as of 16.2.
        // The "resize" event (and therefore _onIronResize) gets fired for
        // orientation changes instead.
        if(window.screen.orientation) {
          window.screen.orientation.addEventListener("change", this._onIronResize.bind(this));
        }

        this.addEventListener("wheel", this._onWheel.bind(this));
        this.addEventListener("pointerdown", this._onPointerDown.bind(this));
        this.addEventListener("pointermove", this._onPointerMove.bind(this));
        this.addEventListener("pointerup", this._onPointerUp.bind(this));

        // DEBUGGING
        // @ts-ignore
        window.z = this;
      },

      // IronResizeBehavior event listeners

      _notifyAll: function(element) {
        return true;
      },

      _notifyNone: function(element) {
        return false;
      },

      _onDimensionsChanged: function(newValue, oldValue) {
        var parts = newValue.toString().split("/");

        var width = this._contentDimensions.width = parseFloat(parts[0]);
        var height = this._contentDimensions.height = parseFloat(parts[1] || 1);
        this._ratio = width / height;

        this._onIronResize();
      },

      _onIronResize: function() {
        if(this.resizerShouldNotify == this._notifyAll) {
          return;
        }

        if(this.fit) {
          this._refitZoom();
        }

        this.resizerShouldNotify = this._notifyAll;
        this.notifyResize();
        this.resizerShouldNotify = this._notifyNone;
      },

      // Zooming event listeners

      _onFit: function(newValue, oldValue) {
        if(!this._readied) {
          return;
        }

        if(!oldValue && this.fit) {
          const lastZoom = this.zoom;

          this.position[0] = 0;
          this.position[1] = 0;
          this._refitZoom();
          const currentZoom = this.zoom;

          // If the zoom wasn't updated, then the viewport wasn't updated.
          if(currentZoom == lastZoom) {
            this._updateViewport();
          }
        }
      },

      _onZoom: function() {
        if(!this._readied) {
          return;
        }

        if(this._notifyFit) {
          this.fit = false;
        }

        this._updateViewport();
      },

      _refitZoom: function() {
        this._notifyFit = false;
        const zoom = Math.min(
          (this.offsetWidth - this.margins*2) / this._contentDimensions.width,
          (this.offsetHeight - this.margins*2) / this._contentDimensions.height
        );
        this.zoom = zoom;
        this._notifyFit = true;
      },

      // Mouse event listeners

      /** @param {PointerEvent} event */
      _onPointerDown: function(event) {
        if(!this.pannable) {
          return;
        }

        if(event.buttons == 4) {
          this.fit = true;
          return;
        }

        this.fit = false;
        this._setPanning(true);
        this._initialPosition = this.position.slice();
        this._initialPointerPosition = [event.clientX, event.clientY];
        this.setPointerCapture(event.pointerId);
      },

      /** @param {PointerEvent} event */
      _onPointerMove: function(event) {
        if(!this.pannable || !this.panning) {
          return;
        }

        this.fit = false;
        const x = event.clientX;
        const y = event.clientY;
        this._panFromInitial(x, y);
      },

      /** @param {PointerEvent} event */
      _onPointerUp: function(event) {
        if(!this.pannable) {
          return;
        }

        this._setPanning(false);
        this._initialPosition = null;
        this._initialPointerPosition = null;
        this.releasePointerCapture(event.pointerId);
      },

      /** @param {WheelEvent} event */
      _onWheel: function(event) {
        const zoomFactor = event.deltaY > 0 ? (100/event.deltaY) : -(event.deltaY/100);
        this._zoomInto(
          event.clientX,
          event.clientY,
          this.zoom * zoomFactor,
        );
      },

      // Zooming/panning methods

      /**
       * Clamps a given value to a given minimum/maximum.
       * 
       * @param {number} n
       * @param {[number, number]}
       *    The minimum and maximum values to clamp to, respectively.
       */
      _clamp: function(n, [min, max]) {
        return Math.min(max, Math.max(min, n));
      },

      /**
       * Pans from an initial point to a given point.
       * `this._initialPosition` and `this._initialPointerPosition` must be set.
       * Otherwise, this does nothing.
       * 
       * @param {number} x
       * @param {number} y
       */
      _panFromInitial: function(x, y) {
        if(!this._initialPosition || !this._initialPointerPosition) {
          return;
        }

        const [iPosX, iPosY] = this._initialPosition;
        const [ix, iy] = this._initialPointerPosition;
        const distanceX = x - ix;
        const distanceY = y - iy;
        this.position[0] = iPosX - distanceX/this.zoom;
        this.position[1] = iPosY - distanceY/this.zoom;
        this._restrictPosition();

        this._updateViewport();
      },

      /**
       * Limits the current position to at least 100px from any edge.
       * 
       * @param {number?} zoom
       */
      _restrictPosition: function(zoom=this.zoom) {
        const minPositionOffset = 100;
        let limX = (this.clientWidth/2 - minPositionOffset) / zoom + this.contentElement.clientWidth/2;
        let limY = (this.clientHeight/2 - minPositionOffset) / zoom + this.contentElement.clientHeight/2;
        this.position[0] = this._clamp(this.position[0], [-limX, limX]);
        this.position[1] = this._clamp(this.position[1], [-limY, limY]);
      },

      /**
       * Zooms the container into a given point.
       * 
       * @param {number} x
       * @param {number} y
       * @param {number} zoom
       *    The target zoom level. Do note that the final zoom level would be clamped
       *    to MINIMUM_ZOOM and MAXIMUM_ZOOM.
       */
      _zoomInto: function(x, y, zoom) {
        const currentZoom = this.zoom;
        zoom = this._clamp(zoom, [this.MINIMUM_ZOOM, this.MAXIMUM_ZOOM]);

        // Offset `this.position` towards [x,y] in the current zoom,
        // then offset away from it with the same distance in the new zoom.
        const viewportX = x - this.offsetWidth/2;
        const viewportY = y - this.offsetHeight/2;
        this.position[0] = (viewportX / currentZoom) + this.position[0] - (viewportX / zoom);
        this.position[1] = (viewportY / currentZoom) + this.position[1] - (viewportY / zoom);
        this._restrictPosition(zoom);

        this.zoom = zoom;
      },

      _updateViewport: function() {
        const x = Math.floor(-this.position[0] * this.zoom);
        const y = Math.floor(-this.position[1] * this.zoom);
        this.contentElement.style.transform = `matrix(${this.zoom}, 0, 0, ${this.zoom}, ${x}, ${y})`;

        // Notify about the canvas bounding rect change down the chain
        this.notifyResize();
      },
    };

    // @ts-ignore
    Polymer(component);
  </script>
</dom-module>
