<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="zoom-container">
  <template>
    <style>
      :host {
        /* Pretty much how you'd normally fit a <div> */
        @apply(--layout-fit);

        /* Pretty much how you'd normally center a <div> */
        @apply(--layout);
        @apply(--layout-center);
        @apply(--layout-center-justified);
      }
    </style>
    <content></content>
  </template>
  <script>
    // @ts-check

    const component = {
      is: 'zoom-container',

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_onIronResize'
      },

      properties: {
        dimensions: {
          type: String,
          value: "1/1",
          observer: '_onDimensionsChanged'
        },

        fit: {
          type: Boolean,
          value: true,
          reflectToAttribute: true,
          observer: "_onFit",
        },

        zoom: {
          type: Number,
          value: 1,  // Relative to the canvas elemt, not the viewport!
          observer: "_onZoom",
        },

        MINIMUM_ZOOM: {
          type: Number,
          value: 0.2,
          readOnly: true,
        },

        MAXIMUM_ZOOM: {
          type: Number,
          value: 10,
          readOnly: true,
        },
      },

      _contentDimensions: {
        width: 1,
        height: 1,
      },

      _ratio: 1,

      _notifyFit: true,

      get contentElement() {
        return this.getContentChildren()[0];
      },

      // Event listeners

      ready: function() {
        // Safari/WebKit doesn't support screen.orientation as of 16.2.
        // The "resize" event (and therefore _onIronResize) gets fired for
        // orientation changes instead.
        if(window.screen.orientation) {
          window.screen.orientation.addEventListener("change", this._onIronResize.bind(this));
        }

        this.addEventListener("wheel", this._onWheel.bind(this));

        // DEBUGGING
        // @ts-ignore
        window.z = this;
      },

      // IronResizeBehavior event listeners

      _notifyAll: function(element) {
        return true;
      },

      _notifyNone: function(element) {
        return false;
      },

      _onDimensionsChanged: function(newValue, oldValue) {
        var parts = newValue.toString().split("/");

        var width = this._contentDimensions.width = parseFloat(parts[0]);
        var height = this._contentDimensions.height = parseFloat(parts[1] || 1);
        this._ratio = width / height;

        this._onIronResize();
      },

      _onIronResize: function() {
        if(this.resizerShouldNotify == this._notifyAll) {
          return;
        }

        this.resizerShouldNotify = this._notifyAll;
        this.notifyResize();
        this.resizerShouldNotify = this._notifyNone;

        if(this.fit) {
          this._refitZoom();
        }
      },

      // Zooming event listeners

      _onFit: function(newValue, oldValue) {
        if(!oldValue && this.fit) {
          this._refitZoom();
        }
      },

      _onZoom: function() {
        if(!this._readied) {
          return;
        }

        if(this._notifyFit) {
          this.fit = false;
        }
      },

      _refitZoom: function() {
        this._notifyFit = false;
        const zoom = Math.min(
          this.offsetWidth / this._contentDimensions.width,
          this.offsetHeight / this._contentDimensions.height
        );
        this.zoom = zoom;
        this._notifyFit = true;
      },

      // Mouse event listeners

      /** @param {WheelEvent} event */
      _onWheel: function(event) {
        const zoomFactor = event.deltaY > 0 ? (100/event.deltaY) : -(event.deltaY/100);
        this._zoomInto(
          event.clientX,
          event.clientY,
          this.zoom * zoomFactor,
        );
      },

      // Zooming methods

      _clamp: function(zoom) {
        return Math.min(this.MAXIMUM_ZOOM, Math.max(this.MINIMUM_ZOOM, zoom));
      },

      /**
       * Zooms the container into a given point.
       * 
       * @param {number} x
       * @param {number} y
       * @param {number} zoom
       *    The target zoom level. Do note that the final zoom level would be clamped
       *    to MINIMUM_ZOOM and MAXIMUM_ZOOM.
       */
      _zoomInto: function(x, y, zoom) {
        zoom = this._clamp(zoom);
        this.zoom = zoom;
      },
    };

    // @ts-ignore
    Polymer(component);
  </script>
</dom-module>
